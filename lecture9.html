

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Lecture 9 &#8212; Lecture notes MATMEK-4270</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'lecture9';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lecture 10" href="lecture10.html" />
    <link rel="prev" title="Lecture 8" href="lecture8.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/uio_logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/uio_logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Lecture Notes MATMEK-4270
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">The Finite Difference Method</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="lecture3.html">Lecture 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture4.html">Lecture 4</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture5.html">Lecture 5</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture6.html">Lecture 6</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture7.html">Lecture 7</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Variational methods</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="lecture8.html">Lecture 8</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 9</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture10.html">Lecture 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture11.html">Lecture 11</a></li>
<li class="toctree-l1"><a class="reference internal" href="lecture12.html">Lecture 12</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mandatory assignments</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mandatory1.html">1. Mandatory assignment due 16/10-2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="mandatory2.html">2. Mandatory assignment due 10 November - 2023</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/MATMEK-4270/matmek4270-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/MATMEK-4270/matmek4270-book/issues/new?title=Issue%20on%20page%20%2Flecture9.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/lecture9.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 9</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-approximation-with-global-functions-continued">Function approximation with global functions continued</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chebyshev-polynomials">Chebyshev polynomials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#two-dimensional-functions">Two-dimensional functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#external-software">External software</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-chebyshev-transforms-optional">Fast Chebyshev transforms - (optional)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#weekly-assignments">Weekly assignments</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-9">
<h1>Lecture 9<a class="headerlink" href="#lecture-9" title="Permalink to this heading">#</a></h1>
<section id="function-approximation-with-global-functions-continued">
<h2>Function approximation with global functions continued<a class="headerlink" href="#function-approximation-with-global-functions-continued" title="Permalink to this heading">#</a></h2>
<p>Legendre polynomials <span class="math notranslate nohighlight">\(\{P_j(x)\}_{j=0}^N, x \in [-1, 1]\)</span> form a basis for the space of all polynomials with order smaller than or equal to <span class="math notranslate nohighlight">\(N\)</span>. This space is normally denoted as <span class="math notranslate nohighlight">\(\mathbb{P}_N\)</span>. The Galerkin method for approximating <span class="math notranslate nohighlight">\(u(x)\)</span> in the space of polynomials <span class="math notranslate nohighlight">\(\mathbb{P}_N\)</span> would normally be formulated as: find <span class="math notranslate nohighlight">\(u_N \in \mathbb{P}_N\)</span> such that</p>
<div class="math notranslate nohighlight" id="equation-eq-project">
<span class="eqno">(19)<a class="headerlink" href="#equation-eq-project" title="Permalink to this equation">#</a></span>\[
(u-u_N, v) = 0, \quad \forall \, v \in \mathbb{P}_N.
\]</div>
<p>Here there is no mentioning of the Legendre polynomials as there is no need for them yet. But the Legendre polynomials <span class="math notranslate nohighlight">\(\{P_j\}_{j=0}^N\)</span> may now be chosen as a basis for <span class="math notranslate nohighlight">\(\mathbb{P}_N\)</span> and we can solve Eq. <a class="reference internal" href="#equation-eq-project">(19)</a> using this basis. The Legendre polynomials are a very good basis because they are orthogonal in <span class="math notranslate nohighlight">\(L^2([-1, 1])\)</span></p>
<div class="math notranslate nohighlight">
\[
\left(P_i, P_j\right)_{L^2([-1,1])} = \frac{2}{2i+1}\delta_{ij}
\]</div>
<p>and very well suited for approximating other smooth functions. However, the Legendre polynomials are not the only possible basis for <span class="math notranslate nohighlight">\(\mathbb{P}_N\)</span>. We can just as easily choose the <span class="math notranslate nohighlight">\(\{x^j\}_{j=0}^N\)</span> and use this basis to solve Eq. <a class="reference internal" href="#equation-eq-project">(19)</a>. But the basis functions <span class="math notranslate nohighlight">\(x^j\)</span> are not orthogonal and the approach is less efficient even though we get exactly the same result. The choice of basis functions is actually very important for the efficiency!</p>
<div class="admonition-nodal-vs-modal-basis admonition">
<p class="admonition-title">Nodal vs modal basis</p>
<p>The Legendre polynomials are often classified as a <strong>modal</strong> basis. A modal basis is not connected in any way to mesh points. The Lagrange polynomials, on the other hand, are often referred to as a <strong>nodal</strong> basis because they rely on mesh points.</p>
</div>
<p>We will now introduce yet another modal polynomial basis that is generally considered to be even better than Legendre: The Chebyshev polynomials!</p>
<section id="chebyshev-polynomials">
<h3>Chebyshev polynomials<a class="headerlink" href="#chebyshev-polynomials" title="Permalink to this heading">#</a></h3>
<p>The Chebyshev polynomials can be defined in their most simple and useful form as</p>
<div class="math notranslate nohighlight" id="equation-eq-chebt">
<span class="eqno">(20)<a class="headerlink" href="#equation-eq-chebt" title="Permalink to this equation">#</a></span>\[
T_k(x) = \cos(k \cos^{-1}(x)), \quad k \in (0, 1, \ldots, N),
\]</div>
<p>for <span class="math notranslate nohighlight">\(x \in [-1, 1]\)</span>. Admittedly, this does not look like polynomials at all, it looks like cosine functions! However, an alternative definition is the recursive form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T_0(x) &amp;= 1, \\
T_1(x) &amp;= x, \\
T_2(x) &amp;= 2x^2-1, \\
&amp;\vdots \\
T_{j+1}(x) &amp;= 2xT_{j}(x) - T_{j-1}(x).
\end{align*}
\end{split}\]</div>
<p>The first 5 polynomials are shown in the figure below</p>
<div class="cell tag_hide-input docutils container" id="fig-chebyshev">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">legend</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">xj</span><span class="p">)))</span>
    <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;$P_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">(x)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legend</span><span class="p">);</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/8d7855d89afec234e0f16f94aa809b18db5da0e5d82748abf1932dcd4cc7eca9.png" src="_images/8d7855d89afec234e0f16f94aa809b18db5da0e5d82748abf1932dcd4cc7eca9.png" />
</div>
</div>
<p>It is noteworthy that all polynomials oscillate between <span class="math notranslate nohighlight">\(-1\)</span> and <span class="math notranslate nohighlight">\(1\)</span>. And all polynomials (<span class="math notranslate nohighlight">\(j&gt;0\)</span>) have maximum and minimum values of exactly 1 and -1. All the <span class="math notranslate nohighlight">\(N+1\)</span> extrema points of <span class="math notranslate nohighlight">\(T_N(x)\)</span> are</p>
<div class="math notranslate nohighlight" id="equation-eq-chebpoints">
<span class="eqno">(21)<a class="headerlink" href="#equation-eq-chebpoints" title="Permalink to this equation">#</a></span>\[
x_j = \cos\left(\frac{j \pi}{N}\right), \quad j \in (0, 1, \ldots, N),
\]</div>
<p>which are called the Chebyshev points. Another set of points are all the roots of <span class="math notranslate nohighlight">\(T_N(x)\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-chebroots">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-chebroots" title="Permalink to this equation">#</a></span>\[
x_j = \cos\left( \frac{(2j+1)\pi}{2N}\right), \quad j \in (0, 1, \ldots, N-1).
\]</div>
<p>The roots are often called the Chebyshev-Gauss points because of their importance in numerical integration through <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gaussian quadrature</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both the roots and the extrema are cosine functions. If we choose <span class="math notranslate nohighlight">\(x=\cos \theta, \, \theta \in [0, \pi]\)</span>, then Eq. <a class="reference internal" href="#equation-eq-chebt">(20)</a> becomes</p>
<div class="math notranslate nohighlight">
\[
T_k(x) = T_k(\cos \theta) =  \cos\left(k \theta \right) 
\]</div>
</div>
<p>Chebyshev polynomials are very efficient to work with because of the link to the cosine function. The cosine function provides an explicit expression that is easy and efficient to evaluate. The Legendre polynomials, on the other hand, do not have such a nice explicit expression and need to rely on the recursive equation <a class="reference internal" href="lecture8.html#equation-eq-legrecursive">(12)</a> for evaluation.</p>
<p>The Chebyshev polynomials form a basis for <span class="math notranslate nohighlight">\(\mathbb{P}_N\)</span>, just like the Legendre polynomials. However, the Chebyshev polynomials are not orthogonal in the <span class="math notranslate nohighlight">\(L^2([-1, 1])\)</span> space! As such, they are not usually used with the Galerkin formulation in Eq. <a class="reference internal" href="#equation-eq-project">(19)</a>.</p>
<p>The Chebyshev polynomials are, on the other hand, orthogonal in a special weighted inner product space. We define the weighted <span class="math notranslate nohighlight">\(L^2_{\omega}(\Omega)\)</span> inner product as</p>
<div class="math notranslate nohighlight">
\[
(f, g)_{L^2_{w}(\Omega)} = \int_{\Omega} f(x)g(x)\omega(x)d\Omega,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega(x)\)</span> is a special weight function. For Chebyshev polynomials defined in <span class="math notranslate nohighlight">\(\Omega = [-1, 1]\)</span> the weight function <span class="math notranslate nohighlight">\(\omega(x) = 1/\sqrt{1-x^2}\)</span>. For simplicity we will write the weighted inner product as <span class="math notranslate nohighlight">\((f, g)_{\omega}\)</span>.</p>
<p>The Chebyshev polynomials are orthogonal in <span class="math notranslate nohighlight">\(L^2_{\omega}([-1, 1])\)</span> and we can easily get</p>
<div class="math notranslate nohighlight" id="equation-eq-chebortho">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-chebortho" title="Permalink to this equation">#</a></span>\[
\left(T_j, T_i \right)_{\omega} = \frac{c_i \pi}{2}\delta_{ij},
\]</div>
<p>where <span class="math notranslate nohighlight">\(c_0=2\)</span> and <span class="math notranslate nohighlight">\(c_i = 1\)</span> for <span class="math notranslate nohighlight">\(i &gt; 0\)</span>.</p>
<p>For Chebyshev polynomials the approximation problem is now solved with the Galerkin method in the <span class="math notranslate nohighlight">\(L^2_{\omega}\)</span> space: find <span class="math notranslate nohighlight">\(u(x) \in \mathbb{P}_N\)</span> such that</p>
<div class="math notranslate nohighlight" id="equation-eq-chebproject">
<span class="eqno">(24)<a class="headerlink" href="#equation-eq-chebproject" title="Permalink to this equation">#</a></span>\[
(u-u_N, v)_{\omega} = 0, \quad \forall \, v \in \mathbb{P}_N.
\]</div>
<p>Other than the special definition of the inner product, the usage is exactly the same as for the Legendre polynomials. Only the integral is changed.</p>
<p>For a problem where <span class="math notranslate nohighlight">\(x \in [a, b]\)</span> we need to map the true domain to the reference domain, exactly like for the Legendre polynomials. We start with the general definition</p>
<div class="math notranslate nohighlight" id="equation-eq-weightedgalerkin">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-weightedgalerkin" title="Permalink to this equation">#</a></span>\[
(u(x)-u_N(x), \psi_i(x))_{\omega} = \int_{a}^b (u(x)-u_N(x)) \psi_i(x) \omega(x) dx = 0, \quad \forall i \in (0, 1, \ldots, N)
\]</div>
<p>which is just a regular Galerkin method using a weighted inner product. Like for Legendre, we use the basis functions in the reference domain, <span class="math notranslate nohighlight">\(\psi_j(x) = T_j(X)\)</span> and the function <span class="math notranslate nohighlight">\(u(x)\)</span> needs a mapping <span class="math notranslate nohighlight">\(u(x(X))\)</span>, where <span class="math notranslate nohighlight">\(x(X)\)</span> means that we compute the physical coordinate <span class="math notranslate nohighlight">\(x\)</span> from the reference <span class="math notranslate nohighlight">\(X\)</span>. The only new thing is the weight function and this weight function is defined for the reference domain: <span class="math notranslate nohighlight">\(\omega(X(x))\)</span>. Naturally, the Chebyshev weight <span class="math notranslate nohighlight">\(\omega(X) = 1/\sqrt{1-X^2}\)</span> only makes sense for the domain <span class="math notranslate nohighlight">\(X \in (-1, 1)\)</span> because the denominator <span class="math notranslate nohighlight">\(1-X^2\)</span> approaches zero for these two edges.</p>
<p>With this in mind we perform a change of variables for <a class="reference internal" href="#equation-eq-weightedgalerkin">(25)</a> where only the function <span class="math notranslate nohighlight">\(u(x(X))\)</span> is written with a mapped argument. The remaining functions are all defined for the reference coordinate <span class="math notranslate nohighlight">\(X\)</span></p>
<div class="math notranslate nohighlight">
\[
\sum_{j=0}^N \int_{-1}^1 T_j  T_i \omega \, \frac{dx}{dX} \, dX \, \hat{u}_j =  \int_{-1}^1 u(x(X)) T_i \omega \, \frac{dx}{dX} \, dX, \quad \forall \, i \in (0, 1, \ldots, N)
\]</div>
<p>As for Legendre the <span class="math notranslate nohighlight">\(dx/dX\)</span> term is constant and can be neglected. We get</p>
<div class="math notranslate nohighlight" id="equation-eq-cheb0">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-cheb0" title="Permalink to this equation">#</a></span>\[
\sum_{j=0}^N  (T_j, T_i)_{L_{\omega}^2([-1,1])} \, \hat{u}_j = (u(x(X)), T_i)_{L_{\omega}^2([-1,1])} \quad \forall \, i \in (0, 1, \ldots, N)
\]</div>
<p>Using the orthogonality <a class="reference internal" href="#equation-eq-chebortho">(23)</a> in <a class="reference internal" href="#equation-eq-cheb0">(26)</a> we get the Chebyshev expansion coefficients</p>
<div class="math notranslate nohighlight" id="equation-eq-cheb-coeff">
<span class="eqno">(27)<a class="headerlink" href="#equation-eq-cheb-coeff" title="Permalink to this equation">#</a></span>\[
\hat{u}_i = \frac{2}{c_i \pi}\left(u(x(X)), T_i\right)_{\omega} \quad \forall \, i \in (0, 1, \ldots, N).
\]</div>
<p>This should be compared with the Legendre coefficients:</p>
<div class="math notranslate nohighlight" id="equation-eq-leg-coeff">
<span class="eqno">(28)<a class="headerlink" href="#equation-eq-leg-coeff" title="Permalink to this equation">#</a></span>\[
\hat{u}_i = \frac{2i+1}{2} \left( u(x(X)), P_i \right) \quad \forall \, i \in (0, 1, \ldots, N).
\]</div>
<p>So for both methods it all boils down to one integral.</p>
<p>The weighted inner product requires some extra attention, though. We need to implement the weighted integral</p>
<div class="math notranslate nohighlight">
\[
(f, T_i)_{\omega} = \int_{-1}^1 \frac{f(x)T_i(x)}{\sqrt{1-x^2}}dx,
\]</div>
<p>which looks intimidating. However, we now remember the Chebyshev link with the cosine function and change variables with <span class="math notranslate nohighlight">\(x=\cos \theta\)</span></p>
<div class="math notranslate nohighlight">
\[
(f, T_i)_{\omega} = \int_{\pi}^{0} \frac{f(\cos \theta)T_i(\cos \theta)}{\sqrt{1-\cos^2 \theta}} \frac{d \cos \theta}{d \theta} d\theta.
\]</div>
<p>Furthermore, we can insert for <span class="math notranslate nohighlight">\( 1-\cos^2\theta = \sin^2\theta\)</span> and swap both the direction of the integration and the sign, which leads to</p>
<div class="math notranslate nohighlight">
\[
(f, T_i)_{\omega}= \int_{0}^{\pi} f(\cos \theta)T_i(\cos \theta) d\theta.
\]</div>
<p>Since <span class="math notranslate nohighlight">\(T_i(\cos \theta) = \cos (i \theta)\)</span> we get the much simpler integral</p>
<div class="math notranslate nohighlight" id="equation-eq-scalarproductt">
<span class="eqno">(29)<a class="headerlink" href="#equation-eq-scalarproductt" title="Permalink to this equation">#</a></span>\[
(f, T_i)_{\omega} = \int_{0}^{\pi} f(\cos \theta)\cos (i \theta) d\theta.
\]</div>
<p>Using this integral, including a mapping of the function <span class="math notranslate nohighlight">\(u(x)\)</span> to the reference domain, we get the Chebyshev coefficients</p>
<div class="math notranslate nohighlight" id="equation-eq-chebcoeff">
<span class="eqno">(30)<a class="headerlink" href="#equation-eq-chebcoeff" title="Permalink to this equation">#</a></span>\[
\hat{u}_i = \frac{2}{c_i \pi}\int_{0}^{\pi} u(x(\cos \theta)) \cos(i \theta) d\theta \quad \forall \, i \in (0, 1, \ldots, N).
\]</div>
<p>Lets try this with a few examples. First we define the exact weighted inner product</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">Tk</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">cj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">innerw</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">ref_domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">ref_domain</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">domain</span>
    <span class="c1"># map u(x(X)) to use reference coordinate X.</span>
    <span class="c1"># Note that x is here ref coord.</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">))</span>
    <span class="c1"># Change variables x=cos(theta)</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">us</span><span class="o">*</span><span class="n">vs</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Note the use of the Sympy function simplify with <code class="docutils literal notranslate"><span class="pre">inverse=True</span></code>, which is required for Sympy to use that <span class="math notranslate nohighlight">\(\cos^{-1}\cos x = x\)</span>.</p>
<p>Compute the Chebyshev coefficients for <span class="math notranslate nohighlight">\(u(x) = 10(x-1)^2-1, \, x \in [1, 2]\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">u</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
<span class="n">uhat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">cj</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">innerw</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Tk</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function <span class="math notranslate nohighlight">\(u(x)\)</span> is defined in the true physical domain with <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>. Inside the <code class="docutils literal notranslate"><span class="pre">innerw</span></code> function we map this to <span class="math notranslate nohighlight">\(u(x(X))\)</span></p>
<div class="math notranslate nohighlight">
\[
u(x(X)) = 10\left(a+\frac{b-a}{B-A}(X-A) -1 \right)^2-1
\]</div>
<p>But we never explicitly create a new symbol X. We just substitute the function <span class="math notranslate nohighlight">\(u\)</span>â€™s coordinate <span class="math notranslate nohighlight">\(x\)</span> for <span class="math notranslate nohighlight">\(a+(b-a)(x-A)/(B-A)\)</span> and use <span class="math notranslate nohighlight">\(x\)</span> as the reference coordinate.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uhj</span> <span class="o">=</span> <span class="n">uhat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">uhat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">uhat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">uhat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">uhat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">uhj</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(11/4, 5, 5/4, 0, 0)
</pre></div>
</div>
</div>
</div>
<p>Note that just like for Legendre 3 coefficients are enough to capture the second order polynomial exactly. For plotting we can use the Numpy class <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html#numpy.polynomial.chebyshev.Chebyshev">Chebyshev</a> with the computed expansion coefficients</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.polynomial</span> <span class="kn">import</span> <span class="n">Chebyshev</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">Chebyshev</span><span class="p">(</span><span class="n">uhj</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">C3</span> <span class="o">=</span> <span class="n">Chebyshev</span><span class="p">(</span><span class="n">uhj</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)(</span><span class="n">xj</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">C2</span><span class="p">(</span><span class="n">xj</span><span class="p">),</span> <span class="s1">&#39;r:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">C3</span><span class="p">(</span><span class="n">xj</span><span class="p">),</span> <span class="s1">&#39;g:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;$10(x-1)^2-1$&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">C2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">C3</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/bef2f7b56b4bb5fe5c49520a1779cca6f34170c637c2aafeee2a3423624e17d8.png" src="_images/bef2f7b56b4bb5fe5c49520a1779cca6f34170c637c2aafeee2a3423624e17d8.png" />
</div>
</div>
<p>Lets try the more difficult function</p>
<div class="math notranslate nohighlight">
\[
u(x) = \exp(\cos x), \quad x \in [-1, 1].
\]</div>
<p>Since the weighted inner product now becomes difficult (at least timeconsuming) for Sympy to integrate exactly, we create a numerical weighted inner product as well.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
<span class="k">def</span> <span class="nf">innerwn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">ref_domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">ref_domain</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">domain</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">))</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">us</span><span class="o">*</span><span class="n">vs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1">#u = 1 / (1+16*x**2)</span>
<span class="c1">#uhat = lambda u, j: 2 / (cj(j) * sp.pi) * innerw(u, Tk(j, x), (-1, 1)) # slow</span>
<span class="n">uhatn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">cj</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">innerwn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Tk</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">uhatn</span></code> computes the Chebyshev expansion coefficients corresponding to Eq. <a class="reference internal" href="#equation-eq-chebcoeff">(30)</a> and we compute the 25 first coefficients below. For comparison we also compute the 25 first Legendre coefficients as well, corresponding to Eq. <a class="reference internal" href="lecture8.html#equation-eq-legcoeff">(16)</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uc</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">25</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">uc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uhatn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="c1"># For Legendre:</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial</span> <span class="kn">import</span> <span class="n">Legendre</span>
<span class="k">def</span> <span class="nf">innern</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">uj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xj</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)(</span><span class="n">xj</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="n">uj</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">uj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">innern</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Legendre</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
<span class="n">ul</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">ul</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uj</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note the numerical implementation of the Legendre inner product. Here we could have used simply</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def innern(u, v):
    return quad(sp.lambdify(x, u*v), -1, 1)[0]
uj = lambda u, j: (2*j+1) * innern(u, sp.legendre(j, x))/2
</pre></div>
</div>
<p>However, this is much more susceptible to roundoff errors. Just try it!</p>
</div>
<p>Plot both Chebyshev and Legendre coefficients in a semilogarithmic plot. Since all the odd coefficients are zero for both Chebyshev and Legendre, we plot only the even coefficients. The odd coefficients are zero because <span class="math notranslate nohighlight">\(u(x)\)</span> is an even function. The Chebyshev and Legendre polynomials are all such that <span class="math notranslate nohighlight">\(\psi_{2i}(x)\)</span> are even, whereas <span class="math notranslate nohighlight">\(\psi_{2i+1}(x)\)</span> are odd. See the <a class="reference internal" href="#fig-chebyshev"><span class="std std-ref">Chebyshev basis functions</span></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">uc</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
             <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ul</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;Legendre&#39;</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f69db304189f51b34ec53a090ae36ad66769946edcb4e7637331c9b73a625d03.png" src="_images/f69db304189f51b34ec53a090ae36ad66769946edcb4e7637331c9b73a625d03.png" />
</div>
</div>
<p>We note that the Chebyshev coefficients are smaller than the Legendre. This is an indication that the Chebyshev polynomials are performing better. However, to say something about the true accuracy we really need to compute the <span class="math notranslate nohighlight">\(L^2\)</span> error norm. Below we compute the <span class="math notranslate nohighlight">\(L^2\)</span> error norm (note, not a weighted norm) for both Legendre and Chebyshev as a function of <span class="math notranslate nohighlight">\(N\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.polynomial</span> <span class="kn">import</span> <span class="n">Legendre</span>

<span class="k">def</span> <span class="nf">L2_error</span><span class="p">(</span><span class="n">uh</span><span class="p">,</span> <span class="n">ue</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="n">Legendre</span><span class="p">):</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">uej</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xj</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uh</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">uj</span> <span class="o">=</span> <span class="n">space</span><span class="p">(</span><span class="n">uh</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)])(</span><span class="n">xj</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">((</span><span class="n">uj</span><span class="o">-</span><span class="n">uej</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">xj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xj</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">err</span>

<span class="n">errc</span> <span class="o">=</span> <span class="n">L2_error</span><span class="p">(</span><span class="n">uc</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Chebyshev</span><span class="p">)</span>
<span class="n">errl</span> <span class="o">=</span> <span class="n">L2_error</span><span class="p">(</span><span class="n">ul</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Legendre</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;./err_u&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">errc</span><span class="p">,</span> <span class="n">errl</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">errc</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
           <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">errl</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">fillstyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;Legendre&#39;</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/602e54575df4787b1f75e46a71b4d51c166a2ba8e0501db7028397c5853b85f4.png" src="_images/602e54575df4787b1f75e46a71b4d51c166a2ba8e0501db7028397c5853b85f4.png" />
</div>
</div>
<p>So there is hardly any difference at all in accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This very fast convergence down to machine precision is often referred to as spectral accuracy. It is actually faster than <strong>any</strong> finite difference method, which always leads to linear decay in the loglog plot above since the error in the finite difference method can be written as some integer order <span class="math notranslate nohighlight">\(r\)</span>, such that the error is <span class="math notranslate nohighlight">\(\mathcal{O}(\Delta x^r)\)</span>.</p>
</div>
</section>
<section id="two-dimensional-functions">
<h3>Two-dimensional functions<a class="headerlink" href="#two-dimensional-functions" title="Permalink to this heading">#</a></h3>
<p>We can approximate a two-dimensional function <span class="math notranslate nohighlight">\(u(x, y)\)</span> using a two-dimensional function space <span class="math notranslate nohighlight">\(W\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[
u(x, y) \approx u_{N}(x, y) = \sum_{i=0}^M \hat{u}_{i}\Psi_{i}(x, y),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Psi_{i}(x, y)\)</span> is a two-dimensional basis function and <span class="math notranslate nohighlight">\(\{\Psi_i(x, y)\}_{i=0}^M\)</span> is a basis for the function space <span class="math notranslate nohighlight">\(W = \text{span}\{\Psi_i(x, y)\}_{i=0}^M\)</span>. Just like in one dimensional space we will write <span class="math notranslate nohighlight">\(u_N\)</span> for the series expansion that approximates <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>There are not all that many two-dimensional basis functions and a more common approach is to use one basis function for the <span class="math notranslate nohighlight">\(x\)</span>-direction and another for the <span class="math notranslate nohighlight">\(y\)</span>-direction</p>
<div class="math notranslate nohighlight">
\[
u_N(x, y) = \sum_{i=0}^M\sum_{j=0}^N \hat{u}_{ij}\psi_{i}(x) \varphi_j(y).
\]</div>
<p>The most straightforward approach is to use the same basis functions for both directions. For example, with a Chebyshev basis</p>
<div class="math notranslate nohighlight">
\[
u_N(x, y) = \sum_{i=0}^M\sum_{j=0}^N \hat{u}_{ij}T_{i}(x)T_j(y).
\]</div>
<p>The two spatial directions have their own domain on the real line, and we use <span class="math notranslate nohighlight">\(I_x = [a, b]\)</span> for the <span class="math notranslate nohighlight">\(x\)</span>-direction and <span class="math notranslate nohighlight">\( I_y = [c, d]\)</span> for the <span class="math notranslate nohighlight">\(y\)</span>-direction. The domain is then the Cartesian product <span class="math notranslate nohighlight">\(\Omega = I_x \times I_y\)</span>.</p>
<p>We can define two one-dimensional function spaces for the two directions as <span class="math notranslate nohighlight">\(V_x = \text{span}\{\psi_i\}_{i=0}^M\)</span> and <span class="math notranslate nohighlight">\(V_y = \text{span}\{\varphi_i\}_{i=0}^N\)</span>. A two-dimensional function space can then be created as</p>
<div class="math notranslate nohighlight">
\[
W = V_x \otimes V_y, \quad (x, y) \in \Omega.
\]</div>
<p>The function space <span class="math notranslate nohighlight">\(W\)</span> is the <em>tensor product</em> of <span class="math notranslate nohighlight">\(V_x\)</span> and <span class="math notranslate nohighlight">\(V_y\)</span>.
The function space <span class="math notranslate nohighlight">\(W\)</span> has a basis that is formed as the tensor product of the basis for <span class="math notranslate nohighlight">\(V_x\)</span> and <span class="math notranslate nohighlight">\(V_y\)</span>. The 2D basis function <span class="math notranslate nohighlight">\(\Psi_{ij}\)</span> is the tensor product of <span class="math notranslate nohighlight">\(\psi_i(x)\)</span> and <span class="math notranslate nohighlight">\(\varphi_j(y)\)</span></p>
<div class="math notranslate nohighlight">
\[
\Psi_{ij}(x, y) = \psi_i(x) \varphi_j(y).
\]</div>
<p>This is also called the outer product, and sometimes also the dyadic product.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="https://matmek-4270.github.io/matmek4270-book/lecture6.html#the-kronecker-product">The Kronecker product</a> is a tensor product.</p>
</div>
<p>The tensor product is related to the Cartesian product. It may actually be viewed as the Cartesian product <em>with multiplication</em>. Consider the Cartesian product of the two sets <span class="math notranslate nohighlight">\((1, 2, 3)\)</span> and <span class="math notranslate nohighlight">\((4, 5)\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
(1, 2, 3) \times (4, 5) = \begin{bmatrix}
(1, 4) \\
(1, 5) \\
(2, 4) \\
(2, 5) \\
(3, 4) \\
(3, 5) \\
\end{bmatrix}
\end{split}\]</div>
<p>and compare with the tensor product</p>
<div class="math notranslate nohighlight">
\[\begin{split}
(1, 2, 3) \otimes (4, 5) = \begin{bmatrix}
1 \cdot 4 \\
1 \cdot 5 \\
2 \cdot 4 \\
2 \cdot 5 \\
3 \cdot 4 \\
3 \cdot 5 
\end{bmatrix}
= 
\begin{bmatrix}
4 \\
5 \\
8 \\
10 \\
12 \\
15 
\end{bmatrix}
\end{split}\]</div>
<p>We see that the tensor product is in fact the Cartesian product with multiplication of the items in each set. The same applies to functions and function spaces. For <span class="math notranslate nohighlight">\(V_x = \text{span}\{\psi_0(x), \psi_1(x)\}\)</span> and <span class="math notranslate nohighlight">\(V_y = \text{span}\{\varphi_0(y), \varphi_1(y)\}\)</span> we have the Cartesian product of the bases</p>
<div class="math notranslate nohighlight">
\[\begin{split}
(\psi_0, \psi_1) \times (\varphi_0, \varphi_1) = \begin{bmatrix}
\left(\psi_0, \varphi_0\right) \\
\left(\psi_0, \varphi_1\right) \\
\left(\psi_1, \varphi_0\right) \\
\left(\psi_1, \varphi_1\right) 
\end{bmatrix}
\end{split}\]</div>
<p>Similarly, the tensor product is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
(\psi_0, \psi_1) \otimes (\varphi_0, \varphi_1) = \begin{bmatrix}
\psi_0 \cdot \varphi_0 \\
\psi_0 \cdot \varphi_1 \\
\psi_1 \cdot \varphi_0 \\
\psi_1 \cdot \varphi_1 
\end{bmatrix}
\end{split}\]</div>
<p>This tensor product is the basis for <span class="math notranslate nohighlight">\(W = V_x \otimes V_y\)</span>. Normally we would also shape the tensor product as a matrix. Here the first basis would be indexed as row and the second as column. This is the normal matrix indexing  <span class="math notranslate nohighlight">\(a_{ij}\)</span>, where <span class="math notranslate nohighlight">\(i\)</span> as row and <span class="math notranslate nohighlight">\(j\)</span> as column.</p>
<div class="math notranslate nohighlight">
\[
\Psi_{ij}(x, y) = \psi_i(x) \varphi_j(y). 
\]</div>
<p>With matrix notation the tensor product can be understood as the matrix-matrix product of a column vector with a row vector:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
(\psi_0, \psi_1) \otimes (\varphi_0, \varphi_1) =  
\begin{bmatrix}
\psi_0 \\
\psi_1
\end{bmatrix}
\begin{bmatrix}
\varphi_0 &amp; \varphi_1
\end{bmatrix} = 
\begin{bmatrix}
\psi_0 \cdot \varphi_0, \psi_0 \cdot \varphi_1 \\
\psi_1 \cdot \varphi_0, \psi_1 \cdot \varphi_1 
\end{bmatrix}
\end{split}\]</div>
<p>For example, we can take the tensor product of the two bases <span class="math notranslate nohighlight">\(\{1, x\}\)</span> and <span class="math notranslate nohighlight">\(\{1, y\}\)</span> in Numpy:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">Vx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="n">Vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Vx</span><span class="p">,</span> <span class="n">Vy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1 y]
 [x x*y]]
</pre></div>
</div>
</div>
</div>
<p>This is exactly</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
1 \\
x
\end{bmatrix}
\begin{bmatrix}
1 &amp; y
\end{bmatrix}
= 
\begin{bmatrix}
1 &amp; y \\
x &amp; xy
\end{bmatrix}
\end{split}\]</div>
<p>Lets try to approximate <span class="math notranslate nohighlight">\(u(x,y) = \exp(-(x^2+2(y-0.5)^2))\)</span>, <span class="math notranslate nohighlight">\((x, y) \in [-1, 1] \times [-1, 1]\)</span> using Legendre polynomials and the Galerkin method. To this end we need the <span class="math notranslate nohighlight">\(L^2(\Omega)\)</span> inner product</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
(f, g) &amp;= \int_{\Omega} f g d\Omega, \\
 &amp;= \int_{-1}^1\int_{-1}^1 f(x,y)g(x,y)dxdy.
\end{align*}
\end{split}\]</div>
<p>Note that the generic first line is identical to the definition used for the 1D case <a class="reference internal" href="lecture8.html#equation-eq-l2-inner">(10)</a>, except that <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> now are functions of both <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>For simplicity we use Legendre polynomials in both directions with the same dimension and space <span class="math notranslate nohighlight">\(V_N = \text{span}\{P_i\}_{i=0}^N\)</span> such that <span class="math notranslate nohighlight">\(W = V_N \otimes V_N\)</span>. We now want to find <span class="math notranslate nohighlight">\(u_N \in W\)</span>  such that</p>
<div class="math notranslate nohighlight">
\[
(u - u_N, v) = 0, \quad \forall \, v \in W.
\]</div>
<p>This means to compute</p>
<div class="math notranslate nohighlight" id="equation-eq-project2d">
<span class="eqno">(31)<a class="headerlink" href="#equation-eq-project2d" title="Permalink to this equation">#</a></span>\[
\int_{-1}^1\int_{-1}^1 \left(u - \sum_{i=0}^N \sum_{j=0}^N \hat{u}_{ij} P_i(x)P_j(y)\right) P_m(x)P_n(y) dx dy = 0, \quad \forall (m, n) \in \mathcal{I}_N^2,
\]</div>
<p>where the index set <span class="math notranslate nohighlight">\(\mathcal{I}_N = (0, 1, \ldots, N)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{I}_N^2 = \mathcal{I}_N \times \mathcal{I}_N\)</span>. The test function <span class="math notranslate nohighlight">\(v\)</span> is here the tensor product basis function <span class="math notranslate nohighlight">\(P_m(x)P_n(y)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Equation <a class="reference internal" href="#equation-eq-project2d">(31)</a> provides <span class="math notranslate nohighlight">\((N+1)^2\)</span> equations for the <span class="math notranslate nohighlight">\((N+1)^2\)</span> unknown in <span class="math notranslate nohighlight">\(\hat{U} = (\hat{u}_{ij})_{i,j=0}^N\)</span>.</p>
</div>
<p>Note that the unknown coefficients <span class="math notranslate nohighlight">\(\hat{u}_{ij}\)</span> are independent of space and we can simplify the double integrals by separating them into one integral for <span class="math notranslate nohighlight">\(x\)</span> and one for <span class="math notranslate nohighlight">\(y\)</span>. We get</p>
<div class="math notranslate nohighlight">
\[
 \int_{-1}^1 \int_{-1}^1 P_i(x)P_j(y) P_m(x)P_n(y) dx dy = \underbrace{\int_{-1}^1 P_i(x)P_m(x)dx}_{a_{im}}  \underbrace{\int_{-1}^1 P_j(y) P_n(y) dy}_{a_{jn}}
\]</div>
<p>and we also write</p>
<div class="math notranslate nohighlight">
\[
u_{mn} = \int_{-1}^1 \int_{-1}^1 u(x, y) P_m(x)P_n(y) dx dy.
\]</div>
<p>We can thus write Eq. <a class="reference internal" href="#equation-eq-project2d">(31)</a> as the linear algebra problem</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=0}^N \sum_{j=0}^N a_{im}a_{jn} \hat{u}_{ij} = u_{mn}.
\]</div>
<p>On matrix form this is</p>
<div class="math notranslate nohighlight">
\[
A \hat{U} A = U,
\]</div>
<p>which can be solved with the vec-trick as</p>
<div class="math notranslate nohighlight">
\[
(A \otimes A) \text{vec}(\hat{U}) = \text{vec}(U).
\]</div>
<p>However, since <span class="math notranslate nohighlight">\(A\)</span> is a diagonal matrix it is actually much easier to just avoid the vectorization and solve directly</p>
<div class="math notranslate nohighlight">
\[
\hat{U} = A^{-1} U A^{-1}.
\]</div>
<p>Lets implement this and verify that the approximation is close to the exact solution. To this end we will now need to use the double integral functions <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.dblquad.html">dblquad</a>. The rest is fairly straight forward:</p>
<div class="cell docutils container" id="impl-dblquad">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">dblquad</span>
<span class="n">ue</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">uh</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">dblquad</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">ue</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">uij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">uij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">uh</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">A_inv</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">uhat_ij</span> <span class="o">=</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="n">uij</span> <span class="o">@</span> <span class="n">A_inv</span>
</pre></div>
</div>
</div>
</div>
<p>At this point we have the coefficients <span class="math notranslate nohighlight">\(\hat{U}\)</span>. For comparison with the exact solution we will to compute the solution in real space for a uniform mesh (meshgrid)</p>
<div class="math notranslate nohighlight">
\[
u(x_i, y_j) = \sum_{m=0}^N \sum_{n=0}^N \hat{u}_{mn} P_m(x_i)P_n(y_j).
\]</div>
<p>To this end we can make use of the Vandermonde matrix</p>
<div class="math notranslate nohighlight">
\[
V = (P_j(x_i))_{i,j=0}^N,
\]</div>
<p>and then (since the mesh is the same in the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> directions) we can simply compute</p>
<div class="math notranslate nohighlight">
\[
U = V \hat{U} V^T.
\]</div>
<p>Below we implement this and compute the <span class="math notranslate nohighlight">\(l^2\)</span> error norm using the exact solution.</p>
<div class="cell docutils container" id="res-legendre-2d">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legvander</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">V</span> <span class="o">@</span> <span class="n">uhat_ij</span> <span class="o">@</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span>
<span class="n">xij</span><span class="p">,</span> <span class="n">yij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ueij</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xij</span><span class="p">,</span> <span class="n">yij</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U</span><span class="o">-</span><span class="n">ueij</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7.519715605065469e-10
</pre></div>
</div>
</div>
</div>
<p>Not bad at all. Lets try for a range of resolutions and plot the <span class="math notranslate nohighlight">\(L^2\)</span> error norm as a function of N</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convergence</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">uij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">uij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">uh</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">A_inv</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">uhat_ij</span> <span class="o">=</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="n">uij</span> <span class="o">@</span> <span class="n">A_inv</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legvander</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">V</span> <span class="o">@</span> <span class="n">uhat_ij</span> <span class="o">@</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span>
    <span class="n">xij</span><span class="p">,</span> <span class="n">yij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ueij</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xij</span><span class="p">,</span> <span class="n">yij</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">((</span><span class="n">U</span><span class="o">-</span><span class="n">ueij</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">h</span><span class="p">),</span> <span class="n">dx</span><span class="o">=</span><span class="n">h</span><span class="p">))</span>

<span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convergence</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">error</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2d2cb65a143ce0ecd24c9e80ed88d68986d03a192df3c25b992e60c8ee0e9924.png" src="_images/2d2cb65a143ce0ecd24c9e80ed88d68986d03a192df3c25b992e60c8ee0e9924.png" />
</div>
</div>
<p>Note the extremely fast convergence. Doubling the number of points in each direction from <span class="math notranslate nohighlight">\(N=10\)</span> to <span class="math notranslate nohighlight">\(N=20\)</span> leads to an error that descreses with 5 decades! This is spectral accuracy. At <span class="math notranslate nohighlight">\(N&gt;20\)</span> the solution does no longer improve because of roundoff errors and machine precision.</p>
</section>
<section id="external-software">
<h3>External software<a class="headerlink" href="#external-software" title="Permalink to this heading">#</a></h3>
<p>Two softwares that are using both Legendre and Chebyshev polynomials for global function approximation and to solve partial differential equations are:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.chebfun.org">Chebfun</a></p></li>
<li><p><a class="reference external" href="https://github.com/spectralDNS/shenfun">Shenfun</a></p></li>
</ul>
<p>Chebfun is mainly focused on Chebyshev polynomials and it is written in MATLAB. Shenfun is written in Python and focuses on solving partial differential equations via the Galerkin method.</p>
<p>Lets try to approximate</p>
<div class="math notranslate nohighlight">
\[
u = \frac{1}{1+16x^2}, \quad x \in [-1, 1]
\]</div>
<p>using Shenfun:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shenfun</span> <span class="k">as</span> <span class="nn">sf</span>

<span class="n">ue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">16</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Legendre&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">uh</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">sf</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ue</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">assemble</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="c1">#uh = sf.project(ue, V) # or just this</span>
</pre></div>
</div>
</div>
</div>
<p>The code should be fairly easy to follow. We simply create the function space <code class="docutils literal notranslate"><span class="pre">V</span></code> <span class="math notranslate nohighlight">\(=\{P_i\}_{i=0}^{N}\)</span>, then a test function <code class="docutils literal notranslate"><span class="pre">v</span></code> from this space and then we compute the Legendre coefficients using the formula in Eq. <a class="reference internal" href="#equation-eq-leg-coeff">(28)</a>.</p>
<p>Note that there is a shortcut function <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.project.project">project</a> that projects <span class="math notranslate nohighlight">\(u(x)\)</span> to the chosen space and basis in one line of code.</p>
<p>We can plot the difference between the computed function and the exact function on a uniform mesh of length 1000:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">uh</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xj</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d29abc8c7bf6c390af8dd2b0f456dce2b95788cd29352466406d40b7ee00092e.png" src="_images/d29abc8c7bf6c390af8dd2b0f456dce2b95788cd29352466406d40b7ee00092e.png" />
</div>
</div>
<p>Notice how the error oscillates all throughout the domain. This is typical of spectral methods.</p>
<p>Lets do exactly the same for Chebyshev polynomials:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Chebyshev&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">cj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">uhc</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">cj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sf</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ue</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">assemble</span><span class="o">=</span><span class="s1">&#39;adaptive&#39;</span><span class="p">)</span>
<span class="c1">#uhc = sf.project(ue, C) # or just this</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">uhc</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span><span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xj</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c271e1a2662fe230e003acc350424a70524a57cf3eb4c75204682e442a29e7e5.png" src="_images/c271e1a2662fe230e003acc350424a70524a57cf3eb4c75204682e442a29e7e5.png" />
</div>
</div>
<p>We see that the error is very similar to the Legendre, but slightly better towards the edges.</p>
<p>Two- and three-dimensional problems can also be solved using shenfun and tensor products. Lets try to approximate <span class="math notranslate nohighlight">\(u(x, y) = \exp(-(x^2+2(y-0.5)^2)\)</span> using Legendre polynomials in both directions and a tensor product function space.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ue</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Legendre&#39;</span><span class="p">)</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">TensorProductSpace</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span>
<span class="n">uh</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">ue</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xij</span><span class="p">,</span> <span class="n">yij</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">local_mesh</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">yij</span><span class="p">,</span> <span class="n">uh</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d7c15b6fd7c9762fdf9d64f5f6f61d512f4871573c036f53b2e1ef3015ecb12f.png" src="_images/d7c15b6fd7c9762fdf9d64f5f6f61d512f4871573c036f53b2e1ef3015ecb12f.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">uh</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">)</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">ue</span><span class="p">)(</span><span class="n">xij</span><span class="p">,</span> <span class="n">yij</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7.165785761229327e-10
</pre></div>
</div>
</div>
</div>
<p>which is very similar to the already computed <a class="reference internal" href="#res-legendre-2d"><span class="std std-ref">above</span></a> without the use of Shenfun.</p>
</section>
<section id="fast-chebyshev-transforms-optional">
<h3>Fast Chebyshev transforms - (optional)<a class="headerlink" href="#fast-chebyshev-transforms-optional" title="Permalink to this heading">#</a></h3>
<p>Besides the closed form, the Chebyshev polynomials have another advantage over Legendre. The Chebyshev series can make use of fast Cosine transforms (similar to fast Fourier transforms) when evaluating a series for Chebyshev points.</p>
<p>Assume that the coefficients <span class="math notranslate nohighlight">\(\{\hat{u}_j\}_{j=0}^N\)</span> are known and you want to evaluate this series on <span class="math notranslate nohighlight">\(N+1\)</span> points in physical space</p>
<div class="math notranslate nohighlight">
\[
u(x_i) = \sum_{j=0}^N \hat{u}_j T_j(x_i), \quad i \in (0, 1, \ldots, N).
\]</div>
<p>Normally this can be computed as a matrix vector product</p>
<div class="math notranslate nohighlight" id="equation-eq-chebvander">
<span class="eqno">(32)<a class="headerlink" href="#equation-eq-chebvander" title="Permalink to this equation">#</a></span>\[
\boldsymbol{u} = \text{T} \boldsymbol{\hat{u}}
\]</div>
<p>where the Vandermonde matrix <span class="math notranslate nohighlight">\(\text{T} = (t_{ij})_{i,j=0}^N, t_{ij} = T_j(x_i)\)</span> is of shape <span class="math notranslate nohighlight">\((N+1) \times (N+1)\)</span>. The cost of this operation is <span class="math notranslate nohighlight">\((2N+1)(N+1)\)</span> floating point operations, and of leading order <span class="math notranslate nohighlight">\(\mathcal{O}(N^2)\)</span>
.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We compute the number of floating point operations for the matrix-vector product as follows: for each of the <span class="math notranslate nohighlight">\(N+1\)</span> rows in the matrix <span class="math notranslate nohighlight">\(\text{T}\)</span>, we hold <span class="math notranslate nohighlight">\(i\)</span> constant and compute <span class="math notranslate nohighlight">\(\sum_{j=0}^N t_{i, j} \cdot \hat{u}_j\)</span>. This requires <span class="math notranslate nohighlight">\(N+1\)</span> multiplications and <span class="math notranslate nohighlight">\(N\)</span> additions, so a total of <span class="math notranslate nohighlight">\(2N+1\)</span> flops. Since there are <span class="math notranslate nohighlight">\(N+1\)</span> rows in the matrix <span class="math notranslate nohighlight">\(\text{T}\)</span>, this is repeated <span class="math notranslate nohighlight">\(N+1\)</span> times. The total cost is as such <span class="math notranslate nohighlight">\((N+1)(2N+1)\)</span> flops.</p>
</div>
<p>The matrix <span class="math notranslate nohighlight">\(\text{T}\)</span> can be computed using <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebvander.html">np.polynomial.chebyshev.chebvander</a>, which can take any vector of points <span class="math notranslate nohighlight">\(\{x_i\}\)</span>, not necessarily of shape <span class="math notranslate nohighlight">\(N+1\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">chebyshev</span><span class="o">.</span><span class="n">chebvander</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">T</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 1.   ,  1.   ,  1.   ,  1.   ,  1.   ,  1.   ],
       [ 1.   ,  0.707,  0.   , -0.707, -1.   , -0.707],
       [ 1.   ,  0.   , -1.   , -0.   ,  1.   ,  0.   ],
       [ 1.   , -0.707, -0.   ,  0.707, -1.   ,  0.707],
       [ 1.   , -1.   ,  1.   , -1.   ,  1.   , -1.   ]])
</pre></div>
</div>
</div>
</div>
<p>Now the column <span class="math notranslate nohighlight">\(j\)</span> in <span class="math notranslate nohighlight">\(\text{T}\)</span> represents the numbers <span class="math notranslate nohighlight">\(\{T_j(x_i)\}_{i=0}^N\)</span>, that is, the basis function <span class="math notranslate nohighlight">\(T_j\)</span> evaluated on the mesh points <span class="math notranslate nohighlight">\(\{x_i\}_{i=0}^N\)</span>.</p>
<p>We can now evaluate <a class="reference internal" href="#equation-eq-chebvander">(32)</a> for any <span class="math notranslate nohighlight">\(\boldsymbol{\hat{u}}\)</span> simply as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">T</span> <span class="o">@</span> <span class="n">uhat</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 3.   , -0.707,  0.   ,  0.707, -3.   ])
</pre></div>
</div>
</div>
</div>
<p>Because of the choice of <span class="math notranslate nohighlight">\(\hat{u} = (0, 1, 0, 1, 0, 1)\)</span> we are now simply computing</p>
<div class="math notranslate nohighlight">
\[
u(\boldsymbol{x}) = T_1(\boldsymbol{x}) + T_3(\boldsymbol{x}) + T_5(\boldsymbol{x}),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{x} = \{\cos(i \pi /5)\}_{i=0}^5\)</span>.</p>
<p>This matrix vector product is the straight forward approach that costs what it costs to do a matrix vector product. However, since the Vandermonde matrix <span class="math notranslate nohighlight">\(\text{T}\)</span> contains evaluated cosines, we can do better.</p>
<p>Lets evaluate the Chebyshev series at the Chebyshev points <a class="reference internal" href="#equation-eq-chebpoints">(21)</a>: <span class="math notranslate nohighlight">\(x_i = \cos(i \pi /N), i \in 0, 1, \ldots, N\)</span>. Using the definition of Chebyshev polynomials <a class="reference internal" href="#equation-eq-chebt">(20)</a> we get</p>
<div class="math notranslate nohighlight" id="equation-eq-uxi">
<span class="eqno">(33)<a class="headerlink" href="#equation-eq-uxi" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{align*}
u(x_i) &amp;= \sum_{j=0}^N \hat{u}_j \cos(j \cos^{-1}(x_i)), \\
 &amp;= \sum_{j=0}^N \hat{u}_j \cos(j i \pi / N),\\
 &amp;= \hat{u}_0 + (-1)^i \hat{u}_N + \sum_{j=1}^{N-1} \hat{u}_j \cos(j i \pi / N),
\end{align*}
\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(i \in (0, 1, \ldots, N)\)</span>.</p>
<p>The <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.fft.dct.html">discrete cosine transform</a> of type 1 is defined to transform the real numbers <span class="math notranslate nohighlight">\(\boldsymbol{y} = \{y_i\}_{i=0}^N\)</span> into <span class="math notranslate nohighlight">\(\boldsymbol{Y}=\{Y_i\}_{i=0}^N\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{Y} = DCT^{1}(\boldsymbol{y}).
\]</div>
<p>From the definition in Scipy we get that this <span class="math notranslate nohighlight">\(DCT^{1}\)</span> really computes</p>
<div class="math notranslate nohighlight">
\[
Y_i = y_0 + (-1)^i y_N + 2 \sum_{j=1}^{N-1} y_j \cos({ji\pi}/{N}), \quad i \in (0, 1, \ldots, N).
\]</div>
<p>This is almost the same as <a class="reference internal" href="#equation-eq-uxi">(33)</a>, except that the sum has a factor 2 in front. But we can work around this. A minor reformulation leads to</p>
<div class="math notranslate nohighlight">
\[
\frac{Y_i + y_0 + (-1)^i y_N}{2} = y_0 + (-1)^i y_N + \sum_{j=1}^{N-1} y_j \cos({ji\pi}/{N}), \quad i \in (0, 1, \ldots, N).
\]</div>
<p>where the right hand side now is exactly like in <a class="reference internal" href="#equation-eq-uxi">(33)</a>. So we need to compute</p>
<div class="math notranslate nohighlight">
\[
u(\boldsymbol{x}) = \frac{DCT^{1}(\boldsymbol{\hat{u}}) + \hat{u}_0 + I_m \hat{u}_N}{2}
\]</div>
<p>where <span class="math notranslate nohighlight">\(I_m = \{(-1)^{i}\}_{i=0}^N\)</span>. We can implement this as shown in the function <code class="docutils literal notranslate"><span class="pre">evaluate_cheb_1</span></code> below</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy</span>

<span class="k">def</span> <span class="nf">evaluate_cheb_1</span><span class="p">(</span><span class="n">uhat</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uhat</span><span class="p">)</span>
    <span class="n">uj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span><span class="n">uhat</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uj</span> <span class="o">+=</span> <span class="n">uhat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">uj</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">uhat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">uj</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">uhat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">uj</span> <span class="o">*=</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">uj</span>
</pre></div>
</div>
</div>
</div>
<p>Lets make sure that this function computes the same as the matrix vector product defined above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">chebyshev</span><span class="o">.</span><span class="n">chebvander</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">uhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">uj</span> <span class="o">=</span> <span class="n">T</span> <span class="o">@</span> <span class="n">uhat</span>
<span class="n">uj_fast</span> <span class="o">=</span> <span class="n">evaluate_cheb_1</span><span class="p">(</span><span class="n">uhat</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">uj</span><span class="p">,</span> <span class="n">uj_fast</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Since the assert is ok this means that the fast transform works.</p>
<p>Lets check the speed of the transforms</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -n 10 uj_fast = evaluate_cheb_1(uhat)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The slowest run took 4.13 times longer than the fastest. This could mean that an intermediate result is being cached.
56.1 Âµs Â± 35.7 Âµs per loop (mean Â± std. dev. of 7 runs, 10 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -n 10 uj = T @ uhat
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>103 Âµs Â± 33.5 Âµs per loop (mean Â± std. dev. of 7 runs, 10 loops each)
</pre></div>
</div>
</div>
</div>
<p>Not a big difference, but this difference will become larger for larger arrays, because the cost of the fast transform is only <span class="math notranslate nohighlight">\(\mathcal{O}(N \log_2 N)\)</span>. Also, the DCT from scipy is not very efficient. Faster versions are available from <a class="reference external" href="https://www.fftw.org">FFTW</a>, wrapped for usage in Python through <a class="reference external" href="https://github.com/mpi4py/mpi4py-fft">mpi4py-fft</a>.</p>
</section>
</section>
<section id="weekly-assignments">
<h2>Weekly assignments<a class="headerlink" href="#weekly-assignments" title="Permalink to this heading">#</a></h2>
<p>Experiment with the Chebyshev Galerkin method and approximate the same global functions that was considered with Legendre and collocation last week:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(u(x) = |x|, \quad x \in [-1, 1]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(x) = \exp(\sin(x)), \quad x \in [0, 2]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(x) = x^{10}, \quad x \in [0, 1]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(x) = \exp(-(x-0.5)^2) - \exp(-0.25) \quad x \in [0, 1]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(x) = J_0(x), \quad x \in [0, 100]\)</span></p></li>
</ol>
<p>Approximate the function <span class="math notranslate nohighlight">\(u(x, y) = \exp(-(x^2+2(y-0.5)^2))\)</span> in the domain <span class="math notranslate nohighlight">\(\Omega = [-1, 1]^2\)</span> with Chebyshev polynomials in both <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>-directions. Try both to implement it yourself, as done for <a class="reference internal" href="#impl-dblquad"><span class="std std-ref">Legendre</span></a>, and by using Shenfun.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "book"
        },
        kernelOptions: {
            name: "book",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'book'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="lecture8.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Lecture 8</p>
      </div>
    </a>
    <a class="right-next"
       href="lecture10.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Lecture 10</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-approximation-with-global-functions-continued">Function approximation with global functions continued</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chebyshev-polynomials">Chebyshev polynomials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#two-dimensional-functions">Two-dimensional functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#external-software">External software</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-chebyshev-transforms-optional">Fast Chebyshev transforms - (optional)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#weekly-assignments">Weekly assignments</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mikael Mortensen
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      Â© Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>
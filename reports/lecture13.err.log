Traceback (most recent call last):
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/asyncio/base_events.py", line 653, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/mikaelmortensen/opt/anaconda3/envs/book/lib/python3.11/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import sympy as sp
import scipy.sparse as sparse

x, t, c, L = sp.Symbol('x,t,c,L')


class Wave1D:
    """Class for solving the wave equation

    Parameters
    ----------
    N : int
        Number of basis functions
    L0 : number
        The extent of the domain, which is [0, L]
    c0 : number, optional
        The wavespeed
    dt : number, optional
        timestep
    u0 : Sympy function of x, t, c and L
        Used for specifying initial condition
    """
    def __init__(self, N, L0=1, c0=1, dt=1, u0=sp.exp(-200*(x-L/2+c*t)**2)):
        self.N = N
        self.L = L0
        self.c = c0
        self.dt = dt
        self.x = np.linspace(0, L0, N+1)
        self.u0 = u0
        self.unp1 = np.zeros(N+1)
        self.un = np.zeros(N+1)
        self.unm1 = np.zeros(N+1)

    def mats(self, bc):
        """Return mass and stiffness matrices

        Paramters
        ---------
        bc : int
            Boundary condition
        """
        N = self.N
        beta = 1/(2*np.arange(N+3)+1)
        a = L/2*sparse.diags([-beta[2:-2], beta[:-2]+beta[2:], beta[2:-2]], [-2, 0, 2], shape=(N+1, N+1))
        s = 2/L*sparse.diags([4*np.arange(N+1)+6], [0], shape=(N+1, N+1))

        if bc == 1: # Neumann condition is baked into stencil
            raise NotImplementedError

        return a, s

    def apply_bcs(self, bc, u=None):
        """Apply boundary conditions to solution vector

        Parameters
        ----------
        bc : int
            Boundary condition in space
            - 0 Dirichlet
            - 1 Neumann
            - 2 Open boundary
            - 3 periodic
        u : array, optional
            The solution array to fix at boundaries
            If not provided, use self.unp1

        """
        u = u if u is not None else self.unp1
        if bc == 0: # Dirichlet condition
            u[0] = 0
            u[-1] = 0

        elif bc == 1: # Neumann condition
            pass

        elif bc == 2: # Open boundary
            raise NotImplementedError

        else:
            raise RuntimeError(f"Wrong bc = {bc}")

    def __call__(self, Nt, dt=None, bc=0, ic=0, save_step=100):
        """Solve wave equation

        Parameters
        ----------
        Nt : int
            Number of time steps
        dt : number
            timestep
        bc : int, optional
            Boundary condition in space
            - 0 Dirichlet
            - 1 Neumann
        ic : int, optional
            Initial conditions
            - 0 Specify un = u(x, t=0) and unm1 = u(x, t=-dt)
            - 1 Specify un = u(x, t=0) and u_t(x, t=0) = 0
        save_step : int, optional
            Save solution every save_step time step

        Returns
        -------
        Dictionary with key, values as timestep, array of solution
        The number of items in the dictionary is Nt/save_step, and
        each value is an array of length N+1

        """
        A, S = self.mats(bc)

        # Initialize
        u0 = sp.lambdify(x, self.u0.subs({L: self.L, c: self.c, t: 0}))
        self.unm1[:] = u0(self.x) # unm1 = u(x, 0)
        plotdata = {0: self.unm1.copy()}
        if ic == 0: # use sympy function for un = u(x, dt)
            u0 = sp.lambdify(x, self.u0.subs({L: self.L, c: self.c, t: dt}))
            self.un[:] = u0(self.x)

        else: # use u_t = 0 for un = u(x, dt)
            self.un[:] = self.unm1 + 0.5*C**2* (D @ self.unm1)
            self.apply_bcs(bc, self.un)
        if save_step == 1:
            plotdata[1] = self.un.copy()

        # Solve
        for n in range(2, Nt+1):
            self.unp1[:] = 2*self.un - self.unm1 + C**2 * (D @ self.un)
            self.apply_bcs(bc)
            self.unm1[:] = self.un
            self.un[:] = self.unp1
            if n % save_step == 0: # save every save_step timestep
                plotdata[n] = self.unp1.copy()

        return plotdata

    def plot_with_offset(self, data):
        Nd = len(data)
        v = np.array(list(data.values()))
        t = np.array(list(data.keys()))
        dt = t[1]-t[0]
        v0 = abs(v).max()
        fig = plt.figure(facecolor='k')
        ax = fig.add_subplot(111, facecolor='k')
        for i, u in data.items():
            ax.plot(self.x, u+i*v0/dt, 'w', lw=2, zorder=i)
            ax.fill_between(self.x, u+i*v0/dt, i*v0/dt, facecolor='k', lw=0, zorder=i-1)
        plt.show()


------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mTypeError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[1], line 5[0m
[1;32m      2[0m [38;5;28;01mimport[39;00m [38;5;21;01msympy[39;00m [38;5;28;01mas[39;00m [38;5;21;01msp[39;00m
[1;32m      3[0m [38;5;28;01mimport[39;00m [38;5;21;01mscipy[39;00m[38;5;21;01m.[39;00m[38;5;21;01msparse[39;00m [38;5;28;01mas[39;00m [38;5;21;01msparse[39;00m
[0;32m----> 5[0m x, t, c, L [38;5;241m=[39m sp[38;5;241m.[39mSymbol([38;5;124m'[39m[38;5;124mx,t,c,L[39m[38;5;124m'[39m)
[1;32m      8[0m [38;5;28;01mclass[39;00m [38;5;21;01mWave1D[39;00m:
[1;32m      9[0m [38;5;250m    [39m[38;5;124;03m"""Class for solving the wave equation[39;00m
[1;32m     10[0m 
[1;32m     11[0m [38;5;124;03m    Parameters[39;00m
[0;32m   (...)[0m
[1;32m     22[0m [38;5;124;03m        Used for specifying initial condition[39;00m
[1;32m     23[0m [38;5;124;03m    """[39;00m

[0;31mTypeError[0m: cannot unpack non-iterable Symbol object

